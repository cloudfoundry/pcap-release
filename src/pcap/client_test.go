package pcap

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
	"github.com/google/gopacket/pcapgo"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/protobuf/types/known/timestamppb"
	"io"
	"net/url"
	"os"
	"sync"
	"testing"
	"time"
)

var examplePacket = []byte{0xfe, 0x0ff, 0x020, 0x000, 0x001, 0x000, 0x000, 0x000, 0x001, 0x000, 0x000, 0x000, 0x008, 0x000, 0x045, 0x000, 0x002, 0x007, 0x00f, 0x045, 0x040, 0x000, 0x080, 0x006, 0x090, 0x010, 0x091, 0x0fe, 0x0a0, 0x0ed, 0x041, 0x0d0, 0x0e4, 0x0df, 0x00d, 0x02c, 0x000, 0x050, 0x038, 0x0af, 0x0fe, 0x014, 0x011, 0x04c, 0x061, 0x08c, 0x050, 0x018, 0x025, 0x0bc, 0x0a9, 0x058, 0x000, 0x000, 0x047, 0x045, 0x054, 0x020, 0x02f, 0x064, 0x06f, 0x077, 0x06e, 0x06c, 0x06f, 0x061, 0x064, 0x02e, 0x068, 0x074, 0x06d, 0x06c, 0x020, 0x048, 0x054, 0x054, 0x050, 0x02f, 0x031, 0x02e, 0x031, 0x00d, 0x00a, 0x048, 0x06f, 0x073, 0x074, 0x03a, 0x020, 0x077, 0x077, 0x077, 0x02e, 0x065, 0x074, 0x068, 0x065, 0x072, 0x065, 0x061, 0x06c, 0x02e, 0x063, 0x06f, 0x06d, 0x00d, 0x00a, 0x055, 0x073, 0x065, 0x072, 0x02d, 0x041, 0x067, 0x065, 0x06e, 0x074, 0x03a, 0x020, 0x04d, 0x06f, 0x07a, 0x069, 0x06c, 0x06c, 0x061, 0x02f, 0x035, 0x02e, 0x030, 0x020, 0x028, 0x057, 0x069, 0x06e, 0x064, 0x06f, 0x077, 0x073, 0x03b, 0x020, 0x055, 0x03b, 0x020, 0x057, 0x069, 0x06e, 0x064, 0x06f, 0x077, 0x073, 0x020, 0x04e, 0x054, 0x020, 0x035, 0x02e, 0x031, 0x03b, 0x020, 0x065, 0x06e, 0x02d, 0x055, 0x053, 0x03b, 0x020, 0x072, 0x076, 0x03a, 0x031, 0x02e, 0x036, 0x029, 0x020, 0x047, 0x065, 0x063, 0x06b, 0x06f, 0x02f, 0x032, 0x030, 0x030, 0x034, 0x030, 0x031, 0x031, 0x033, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x03a, 0x020, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x078, 0x06d, 0x06c, 0x02c, 0x061, 0x070, 0x070, 0x06c, 0x069, 0x063, 0x061, 0x074, 0x069, 0x06f, 0x06e, 0x02f, 0x078, 0x06d, 0x06c, 0x02c, 0x061, 0x070, 0x070, 0x06c, 0x069, 0x063, 0x061, 0x074, 0x069, 0x06f, 0x06e, 0x02f, 0x078, 0x068, 0x074, 0x06d, 0x06c, 0x02b, 0x078, 0x06d, 0x06c, 0x02c, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x068, 0x074, 0x06d, 0x06c, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x039, 0x02c, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x070, 0x06c, 0x061, 0x069, 0x06e, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x038, 0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x070, 0x06e, 0x067, 0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x06a, 0x070, 0x065, 0x067, 0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x067, 0x069, 0x066, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x032, 0x02c, 0x02a, 0x02f, 0x02a, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x031, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x04c, 0x061, 0x06e, 0x067, 0x075, 0x061, 0x067, 0x065, 0x03a, 0x020, 0x065, 0x06e, 0x02d, 0x075, 0x073, 0x02c, 0x065, 0x06e, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x035, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x045, 0x06e, 0x063, 0x06f, 0x064, 0x069, 0x06e, 0x067, 0x03a, 0x020, 0x067, 0x07a, 0x069, 0x070, 0x02c, 0x064, 0x065, 0x066, 0x06c, 0x061, 0x074, 0x065, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x043, 0x068, 0x061, 0x072, 0x073, 0x065, 0x074, 0x03a, 0x020, 0x049, 0x053, 0x04f, 0x02d, 0x038, 0x038, 0x035, 0x039, 0x02d, 0x031, 0x02c, 0x075, 0x074, 0x066, 0x02d, 0x038, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x037, 0x02c, 0x02a, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x037, 0x00d, 0x00a, 0x04b, 0x065, 0x065, 0x070, 0x02d, 0x041, 0x06c, 0x069, 0x076, 0x065, 0x03a, 0x020, 0x033, 0x030, 0x030, 0x00d, 0x00a, 0x043, 0x06f, 0x06e, 0x06e, 0x065, 0x063, 0x074, 0x069, 0x06f, 0x06e, 0x03a, 0x020, 0x06b, 0x065, 0x065, 0x070, 0x02d, 0x061, 0x06c, 0x069, 0x076, 0x065, 0x00d, 0x00a, 0x052, 0x065, 0x066, 0x065, 0x072, 0x065, 0x072, 0x03a, 0x020, 0x068, 0x074, 0x074, 0x070, 0x03a, 0x02f, 0x02f, 0x077, 0x077, 0x077, 0x02e, 0x065, 0x074, 0x068, 0x065, 0x072, 0x065, 0x061, 0x06c, 0x02e, 0x063, 0x06f, 0x06d, 0x02f, 0x064, 0x065, 0x076, 0x065, 0x06c, 0x06f, 0x070, 0x06d, 0x065, 0x06e, 0x074, 0x02e, 0x068, 0x074, 0x06d, 0x06c, 0x00d, 0x00a, 0x00d, 0x00a, 0x0}

type MessageTuple struct {
	Response *CaptureResponse
	err      error
}

type MockAPIWriter struct {
	index    int
	messages []MessageTuple
	grpc.ClientStream
}

func (x *MockAPIWriter) Send(m *CaptureRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *MockAPIWriter) Recv() (*CaptureResponse, error) {
	if x.index >= len(x.messages) {
		return nil, io.EOF
	}
	response := x.messages[x.index].Response
	err := x.messages[x.index].err
	x.index++
	return response, err
}

func TestHandleStream(t *testing.T) {
	tests := []struct {
		name               string
		clientError        error
		messages           []MessageTuple
		expectedErrMessage string
	}{
		{
			name:        "clean stop",
			clientError: nil,
			messages: []MessageTuple{
				{
					Response: newPacketResponse(examplePacket, gopacket.CaptureInfo{}),
				},
			},
			expectedErrMessage: "context canceled",
		}, {
			name:        "client stop",
			clientError: fmt.Errorf("client stop"),
			messages: []MessageTuple{
				{
					Response: newPacketResponse(examplePacket, gopacket.CaptureInfo{}),
				},
			},
			expectedErrMessage: "client stop",
		}, {
			name:        "Permission Denied",
			clientError: nil,
			messages: []MessageTuple{
				{
					err: errorf(codes.PermissionDenied, "error-text"),
				},
			},
			expectedErrMessage: "receive non-OK code: {code 25 0  PermissionDenied}: {error 26 0  error-text}\n",
		},
	}

	for _, tt := range tests {
		var buf bytes.Buffer
		writer := pcapgo.NewWriter(&buf)
		copyWg := &sync.WaitGroup{}
		copyWg.Add(1)
		stream := &MockAPIWriter{messages: tt.messages}
		ctx, cancel := WithCancelCause(context.Background())
		go handleStream(stream, writer, copyWg, cancel)
		if tt.clientError != nil {
			cancel(tt.clientError)
		}
		copyWg.Wait()

		err := Cause(ctx)
		if err.Error() != tt.expectedErrMessage {
			t.Errorf("expected = %v, actual = %v", tt.expectedErrMessage, err)
		}
	}
}

func TestNewClient(t *testing.T) {
	log := zap.L()

	tests := []struct {
		name        string
		outputFile  string
		apiURL      *url.URL
		wantErr     bool
		expectedErr error
	}{
		{
			name:       "valid configuration", //TODO mock api or skip test/make integration test?
			outputFile: "",
			apiURL: &url.URL{
				Scheme: "http",
				Host:   "localhost:8080",
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		client, err := NewClient(tt.outputFile, tt.apiURL, log)
		if (err != nil) != tt.wantErr {
			t.Errorf("wantErr = %v, error = %v", tt.wantErr, err)
		}
		if tt.expectedErr != nil && !errors.Is(err, tt.expectedErr) {
			t.Errorf("expectedErr = %v, actualErr = %v", tt.expectedErr, err)
		}
		if client == nil {
			t.Errorf("client is nil")
		}
	}
}

// writes a predefined packet to a pcap-file, parses the file and compares timestamp and destination port
func TestWritePacket(t *testing.T) {
	filename := "testfile.pcap"
	file, err := os.Create(filename)
	if err != nil {
		t.Errorf("unexpected error: %v", err.Error())
	}
	packetWriter := pcapgo.NewWriter(file)
	err = packetWriter.WriteFileHeader(65000, layers.LinkTypeEthernet)
	if err != nil {
		t.Errorf("unexpected error: %v", err.Error())
	}

	testTimestamp := time.Date(2023, 01, 01, 13, 37, 0, 0, time.Local) // fixme: test fails when using a non-local timezone or time.Now(). potential issue with our usage of either protobuf timestamps or packet.Metadata().Timestamp

	packet := &Packet{
		Data:      examplePacket,
		Timestamp: timestamppb.New(testTimestamp),
		Length:    int32(len(examplePacket)),
	}

	writePacket(packet, packetWriter)

	handle, err := pcap.OpenOffline(filename)
	if err != nil {
		t.Errorf("could not parse pcap file")
	}
	defer handle.Close()

	// Loop through packets in file
	packetSource := gopacket.NewPacketSource(handle, handle.LinkType())

	// Loop through packets in file
	var packets []gopacket.Packet
	for packet := range packetSource.Packets() {
		packets = append(packets, packet)
	}

	if len(packets) != 1 {
		t.Errorf("unexpected number of packets: %v", len(packets))
	}

	actualTimestamp := packets[0].Metadata().Timestamp

	if actualTimestamp != testTimestamp {
		t.Errorf("mismatching timestamps. expected %v, actual %v", testTimestamp, actualTimestamp)
	}
	transportLayer := packets[0].TransportLayer()
	dstPort := transportLayer.TransportFlow().Dst().String()
	if dstPort != "80" {
		t.Errorf("unexpected destination port %v", dstPort)
	}
}

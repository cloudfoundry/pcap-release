package pcap

import (
	"errors"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
	"github.com/google/gopacket/pcapgo"
	"go.uber.org/zap"
	"google.golang.org/protobuf/types/known/timestamppb"
	"os"
	"testing"
	"time"
)

func TestNewClient(t *testing.T) {
	log := zap.L()

	tests := []struct {
		name        string
		outputFile  string
		apiURL      string
		stopChannel chan StopSignal
		wantErr     bool
		expectedErr error
	}{
		{
			name:       "valid configuration", //TODO
			outputFile: "",
			apiURL:     "",
			wantErr:    false,
		},
	}

	for _, test := range tests {
		client, err := NewClient(test.outputFile, test.apiURL, test.stopChannel, log)
		if (err != nil) != test.wantErr {
			t.Errorf("wantErr = %v, error = %v", test.wantErr, err)
		}
		if test.expectedErr != nil && !errors.Is(err, test.expectedErr) {
			t.Errorf("expectedErr = %v, actualErr = %v", test.expectedErr, err)
		}
		if client == nil {
			t.Errorf("client is nil")
		}
	}
}

func TestClient_HandleRequest(t *testing.T) {

}

// writes a predefined packet to a pcap-file, parses the file and compares timestamp and destination port
func TestClient_writePacket(t *testing.T) {
	filename := "testfile.pcap"
	file, err := os.Create(filename)
	if err != nil {
		t.Errorf("unexpected error: %v", err.Error())
	}
	packetWriter := pcapgo.NewWriter(file)
	err = packetWriter.WriteFileHeader(65000, layers.LinkTypeEthernet)
	if err != nil {
		t.Errorf("unexpected error: %v", err.Error())
	}

	// example HTTP packet (destination port 80
	data := []byte{0xfe, 0x0ff, 0x020, 0x000, 0x001, 0x000, 0x000, 0x000, 0x001, 0x000, 0x000, 0x000, 0x008, 0x000, 0x045, 0x000, 0x002, 0x007, 0x00f, 0x045, 0x040, 0x000, 0x080, 0x006, 0x090, 0x010, 0x091, 0x0fe, 0x0a0, 0x0ed, 0x041, 0x0d0, 0x0e4, 0x0df, 0x00d, 0x02c, 0x000, 0x050, 0x038, 0x0af, 0x0fe, 0x014, 0x011, 0x04c, 0x061, 0x08c, 0x050, 0x018, 0x025, 0x0bc, 0x0a9, 0x058, 0x000, 0x000, 0x047, 0x045, 0x054, 0x020, 0x02f, 0x064, 0x06f, 0x077, 0x06e, 0x06c, 0x06f, 0x061, 0x064, 0x02e, 0x068, 0x074, 0x06d, 0x06c, 0x020, 0x048, 0x054, 0x054, 0x050, 0x02f, 0x031, 0x02e, 0x031, 0x00d, 0x00a, 0x048, 0x06f, 0x073, 0x074, 0x03a, 0x020, 0x077, 0x077, 0x077, 0x02e, 0x065, 0x074, 0x068, 0x065, 0x072, 0x065, 0x061, 0x06c, 0x02e, 0x063, 0x06f, 0x06d, 0x00d, 0x00a, 0x055, 0x073, 0x065, 0x072, 0x02d, 0x041, 0x067, 0x065, 0x06e, 0x074, 0x03a, 0x020, 0x04d, 0x06f, 0x07a, 0x069, 0x06c, 0x06c, 0x061, 0x02f, 0x035, 0x02e, 0x030, 0x020, 0x028, 0x057, 0x069, 0x06e, 0x064, 0x06f, 0x077, 0x073, 0x03b, 0x020, 0x055, 0x03b, 0x020, 0x057, 0x069, 0x06e, 0x064, 0x06f, 0x077, 0x073, 0x020, 0x04e, 0x054, 0x020, 0x035, 0x02e, 0x031, 0x03b, 0x020, 0x065, 0x06e, 0x02d, 0x055, 0x053, 0x03b, 0x020, 0x072, 0x076, 0x03a, 0x031, 0x02e, 0x036, 0x029, 0x020, 0x047, 0x065, 0x063, 0x06b, 0x06f, 0x02f, 0x032, 0x030, 0x030, 0x034, 0x030, 0x031, 0x031, 0x033, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x03a, 0x020, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x078, 0x06d, 0x06c, 0x02c, 0x061, 0x070, 0x070, 0x06c, 0x069, 0x063, 0x061, 0x074, 0x069, 0x06f, 0x06e, 0x02f, 0x078, 0x06d, 0x06c, 0x02c, 0x061, 0x070, 0x070, 0x06c, 0x069, 0x063, 0x061, 0x074, 0x069, 0x06f, 0x06e, 0x02f, 0x078, 0x068, 0x074, 0x06d, 0x06c, 0x02b, 0x078, 0x06d, 0x06c, 0x02c, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x068, 0x074, 0x06d, 0x06c, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x039, 0x02c, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x070, 0x06c, 0x061, 0x069, 0x06e, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x038, 0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x070, 0x06e, 0x067, 0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x06a, 0x070, 0x065, 0x067, 0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x067, 0x069, 0x066, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x032, 0x02c, 0x02a, 0x02f, 0x02a, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x031, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x04c, 0x061, 0x06e, 0x067, 0x075, 0x061, 0x067, 0x065, 0x03a, 0x020, 0x065, 0x06e, 0x02d, 0x075, 0x073, 0x02c, 0x065, 0x06e, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x035, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x045, 0x06e, 0x063, 0x06f, 0x064, 0x069, 0x06e, 0x067, 0x03a, 0x020, 0x067, 0x07a, 0x069, 0x070, 0x02c, 0x064, 0x065, 0x066, 0x06c, 0x061, 0x074, 0x065, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x043, 0x068, 0x061, 0x072, 0x073, 0x065, 0x074, 0x03a, 0x020, 0x049, 0x053, 0x04f, 0x02d, 0x038, 0x038, 0x035, 0x039, 0x02d, 0x031, 0x02c, 0x075, 0x074, 0x066, 0x02d, 0x038, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x037, 0x02c, 0x02a, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x037, 0x00d, 0x00a, 0x04b, 0x065, 0x065, 0x070, 0x02d, 0x041, 0x06c, 0x069, 0x076, 0x065, 0x03a, 0x020, 0x033, 0x030, 0x030, 0x00d, 0x00a, 0x043, 0x06f, 0x06e, 0x06e, 0x065, 0x063, 0x074, 0x069, 0x06f, 0x06e, 0x03a, 0x020, 0x06b, 0x065, 0x065, 0x070, 0x02d, 0x061, 0x06c, 0x069, 0x076, 0x065, 0x00d, 0x00a, 0x052, 0x065, 0x066, 0x065, 0x072, 0x065, 0x072, 0x03a, 0x020, 0x068, 0x074, 0x074, 0x070, 0x03a, 0x02f, 0x02f, 0x077, 0x077, 0x077, 0x02e, 0x065, 0x074, 0x068, 0x065, 0x072, 0x065, 0x061, 0x06c, 0x02e, 0x063, 0x06f, 0x06d, 0x02f, 0x064, 0x065, 0x076, 0x065, 0x06c, 0x06f, 0x070, 0x06d, 0x065, 0x06e, 0x074, 0x02e, 0x068, 0x074, 0x06d, 0x06c, 0x00d, 0x00a, 0x00d, 0x00a, 0x0}

	testTimestamp := time.Date(2023, 01, 01, 13, 37, 0, 0, time.Local) // fixme: test fails when using a non-local timezone or time.Now(). potential issue with our usage of either protobuf timestamps or packet.Metadata().Timestamp

	packet := &Packet{
		Data:      data,
		Timestamp: timestamppb.New(testTimestamp),
		Length:    int32(len(data)),
	}

	client := &Client{logger: zap.L()}
	client.writePacket(packet, packetWriter)

	handle, err := pcap.OpenOffline(filename)
	if err != nil {
		t.Errorf("could not parse pcap file")
	}
	defer handle.Close()

	// Loop through packets in file
	packetSource := gopacket.NewPacketSource(handle, handle.LinkType())

	// Loop through packets in file
	var packets []gopacket.Packet
	for packet := range packetSource.Packets() {
		packets = append(packets, packet)
	}

	if len(packets) != 1 {
		t.Errorf("unexpected number of packets: %v", len(packets))
	}

	actualTimestamp := packets[0].Metadata().Timestamp

	if actualTimestamp != testTimestamp {
		t.Errorf("mismatching timestamps. expected %v, actual %v", testTimestamp, actualTimestamp)
	}
	transportLayer := packets[0].TransportLayer()
	dstPort := transportLayer.TransportFlow().Dst().String()
	if dstPort != "80" {
		t.Errorf("unexpected destination port %v", dstPort)
	}

}

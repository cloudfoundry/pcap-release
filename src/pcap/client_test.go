package pcap

import (
	"bytes"
	"context"
	"io"
	"os"
	"testing"
	"time"

	"github.com/gopacket/gopacket"
	"github.com/gopacket/gopacket/layers"
	"github.com/gopacket/gopacket/pcap"
	"github.com/gopacket/gopacket/pcapgo"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/protobuf/types/known/timestamppb"
)

var examplePacket = []byte{
	0xfe, 0x0ff, 0x020, 0x000, 0x001, 0x000, 0x000, 0x000, 0x001, 0x000, 0x000, 0x000, 0x008, 0x000, 0x045, 0x000,
	0x002, 0x007, 0x00f, 0x045, 0x040, 0x000, 0x080, 0x006, 0x090, 0x010, 0x091, 0x0fe, 0x0a0, 0x0ed, 0x041, 0x0d0,
	0x0e4, 0x0df, 0x00d, 0x02c, 0x000, 0x050, 0x038, 0x0af, 0x0fe, 0x014, 0x011, 0x04c, 0x061, 0x08c, 0x050, 0x018,
	0x025, 0x0bc, 0x0a9, 0x058, 0x000, 0x000, 0x047, 0x045, 0x054, 0x020, 0x02f, 0x064, 0x06f, 0x077, 0x06e, 0x06c,
	0x06f, 0x061, 0x064, 0x02e, 0x068, 0x074, 0x06d, 0x06c, 0x020, 0x048, 0x054, 0x054, 0x050, 0x02f, 0x031, 0x02e,
	0x031, 0x00d, 0x00a, 0x048, 0x06f, 0x073, 0x074, 0x03a, 0x020, 0x077, 0x077, 0x077, 0x02e, 0x065, 0x074, 0x068,
	0x065, 0x072, 0x065, 0x061, 0x06c, 0x02e, 0x063, 0x06f, 0x06d, 0x00d, 0x00a, 0x055, 0x073, 0x065, 0x072, 0x02d,
	0x041, 0x067, 0x065, 0x06e, 0x074, 0x03a, 0x020, 0x04d, 0x06f, 0x07a, 0x069, 0x06c, 0x06c, 0x061, 0x02f, 0x035,
	0x02e, 0x030, 0x020, 0x028, 0x057, 0x069, 0x06e, 0x064, 0x06f, 0x077, 0x073, 0x03b, 0x020, 0x055, 0x03b, 0x020,
	0x057, 0x069, 0x06e, 0x064, 0x06f, 0x077, 0x073, 0x020, 0x04e, 0x054, 0x020, 0x035, 0x02e, 0x031, 0x03b, 0x020,
	0x065, 0x06e, 0x02d, 0x055, 0x053, 0x03b, 0x020, 0x072, 0x076, 0x03a, 0x031, 0x02e, 0x036, 0x029, 0x020, 0x047,
	0x065, 0x063, 0x06b, 0x06f, 0x02f, 0x032, 0x030, 0x030, 0x034, 0x030, 0x031, 0x031, 0x033, 0x00d, 0x00a, 0x041,
	0x063, 0x063, 0x065, 0x070, 0x074, 0x03a, 0x020, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x078, 0x06d, 0x06c, 0x02c,
	0x061, 0x070, 0x070, 0x06c, 0x069, 0x063, 0x061, 0x074, 0x069, 0x06f, 0x06e, 0x02f, 0x078, 0x06d, 0x06c, 0x02c,
	0x061, 0x070, 0x070, 0x06c, 0x069, 0x063, 0x061, 0x074, 0x069, 0x06f, 0x06e, 0x02f, 0x078, 0x068, 0x074, 0x06d,
	0x06c, 0x02b, 0x078, 0x06d, 0x06c, 0x02c, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x068, 0x074, 0x06d, 0x06c, 0x03b,
	0x071, 0x03d, 0x030, 0x02e, 0x039, 0x02c, 0x074, 0x065, 0x078, 0x074, 0x02f, 0x070, 0x06c, 0x061, 0x069, 0x06e,
	0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x038, 0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x070, 0x06e, 0x067,
	0x02c, 0x069, 0x06d, 0x061, 0x067, 0x065, 0x02f, 0x06a, 0x070, 0x065, 0x067, 0x02c, 0x069, 0x06d, 0x061, 0x067,
	0x065, 0x02f, 0x067, 0x069, 0x066, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x032, 0x02c, 0x02a, 0x02f, 0x02a, 0x03b,
	0x071, 0x03d, 0x030, 0x02e, 0x031, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x04c, 0x061,
	0x06e, 0x067, 0x075, 0x061, 0x067, 0x065, 0x03a, 0x020, 0x065, 0x06e, 0x02d, 0x075, 0x073, 0x02c, 0x065, 0x06e,
	0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x035, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x045,
	0x06e, 0x063, 0x06f, 0x064, 0x069, 0x06e, 0x067, 0x03a, 0x020, 0x067, 0x07a, 0x069, 0x070, 0x02c, 0x064, 0x065,
	0x066, 0x06c, 0x061, 0x074, 0x065, 0x00d, 0x00a, 0x041, 0x063, 0x063, 0x065, 0x070, 0x074, 0x02d, 0x043, 0x068,
	0x061, 0x072, 0x073, 0x065, 0x074, 0x03a, 0x020, 0x049, 0x053, 0x04f, 0x02d, 0x038, 0x038, 0x035, 0x039, 0x02d,
	0x031, 0x02c, 0x075, 0x074, 0x066, 0x02d, 0x038, 0x03b, 0x071, 0x03d, 0x030, 0x02e, 0x037, 0x02c, 0x02a, 0x03b,
	0x071, 0x03d, 0x030, 0x02e, 0x037, 0x00d, 0x00a, 0x04b, 0x065, 0x065, 0x070, 0x02d, 0x041, 0x06c, 0x069, 0x076,
	0x065, 0x03a, 0x020, 0x033, 0x030, 0x030, 0x00d, 0x00a, 0x043, 0x06f, 0x06e, 0x06e, 0x065, 0x063, 0x074, 0x069,
	0x06f, 0x06e, 0x03a, 0x020, 0x06b, 0x065, 0x065, 0x070, 0x02d, 0x061, 0x06c, 0x069, 0x076, 0x065, 0x00d, 0x00a,
	0x052, 0x065, 0x066, 0x065, 0x072, 0x065, 0x072, 0x03a, 0x020, 0x068, 0x074, 0x074, 0x070, 0x03a, 0x02f, 0x02f,
	0x077, 0x077, 0x077, 0x02e, 0x065, 0x074, 0x068, 0x065, 0x072, 0x065, 0x061, 0x06c, 0x02e, 0x063, 0x06f, 0x06d,
	0x02f, 0x064, 0x065, 0x076, 0x065, 0x06c, 0x06f, 0x070, 0x06d, 0x065, 0x06e, 0x074, 0x02e, 0x068, 0x074, 0x06d,
	0x06c, 0x00d, 0x00a, 0x00d, 0x00a, 0x0}

type MessageTuple struct {
	Response *CaptureResponse
	err      error
}

type MockAPIWriter struct {
	index    int
	messages []MessageTuple
	grpc.ClientStream
}

func (x *MockAPIWriter) Send(m *CaptureRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *MockAPIWriter) Recv() (*CaptureResponse, error) {
	if x.index >= len(x.messages) {
		return nil, io.EOF
	}
	response := x.messages[x.index].Response
	err := x.messages[x.index].err
	x.index++
	return response, err
}

func TestHandleStream(t *testing.T) {
	tests := []struct {
		name               string
		clientError        error
		messages           []MessageTuple
		expectedErrMessage string
	}{
		{
			name:        "clean stop",
			clientError: nil,
			messages: []MessageTuple{
				{
					Response: newPacketResponse(examplePacket, gopacket.CaptureInfo{}),
				},
			},
			expectedErrMessage: "context canceled",
		}, {
			name:        "client stop",
			clientError: context.Canceled,
			messages: []MessageTuple{
				{
					Response: newPacketResponse(examplePacket, gopacket.CaptureInfo{}),
				},
			},
			expectedErrMessage: "context canceled",
		}, {
			name:        "Permission Denied",
			clientError: nil,
			messages: []MessageTuple{
				{
					err: errorf(codes.PermissionDenied, "error-text"),
				},
			},
			expectedErrMessage: "receive non-OK code: PermissionDenied: error-text",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			writer := pcapgo.NewWriter(&buf)
			stream := &MockAPIWriter{messages: tt.messages}
			ctx, cancel := context.WithCancelCause(context.Background())
			c := Client{log: zap.L().With(zap.String("test", tt.name))}
			done := c.ReadCaptureResponse(stream, writer, cancel)
			if tt.clientError != nil {
				cancel(tt.clientError)
			}
			<-done

			err := context.Cause(ctx)
			if err.Error() != tt.expectedErrMessage {
				t.Errorf("expected = %v, actual = %v", tt.expectedErrMessage, err)
			}
		})
	}
}

// TestWritePacket writes a predefined packet to a pcap-file, parses the file and compares timestamp and destination port.
func TestWritePacket(t *testing.T) {
	filename := "testfile.pcap"
	file, err := os.Create(filename)
	if err != nil {
		t.Errorf("unexpected error: %v", err.Error())
	}
	packetWriter := pcapgo.NewWriter(file)
	err = packetWriter.WriteFileHeader(65000, layers.LinkTypeEthernet)
	if err != nil {
		t.Errorf("unexpected error: %v", err.Error())
	}

	// force UTC time zone, as the reading from the file is done in the local time zone. This ensures that time zone
	// conversions are handled correctly.
	testTimestamp := time.Now().UTC()

	packet := &Packet{
		Data:      examplePacket,
		Timestamp: timestamppb.New(testTimestamp),
		Length:    int32(len(examplePacket)),
	}

	writePacket(packet, packetWriter)

	handle, err := pcap.OpenOffline(filename)
	if err != nil {
		t.Errorf("could not parse pcap file")
	}
	defer handle.Close()

	// Loop through packets in file
	packetSource := gopacket.NewPacketSource(handle, handle.LinkType())

	// Loop through packets in file
	var packets []gopacket.Packet
	for packet := range packetSource.Packets() {
		packets = append(packets, packet)
	}

	if len(packets) != 1 {
		t.Errorf("unexpected number of packets: %v", len(packets))
	}
	actualTimestamp := packets[0].Metadata().Timestamp

	// account for inaccuracy in time formats stored in pcap file
	if delta := testTimestamp.Sub(actualTimestamp); delta > time.Microsecond {
		t.Errorf("mismatching timestamps. expected %v, actual %v, delta: %+v", testTimestamp, actualTimestamp, delta)
	}
	transportLayer := packets[0].TransportLayer()
	dstPort := transportLayer.TransportFlow().Dst().String()
	if dstPort != "80" {
		t.Errorf("unexpected destination port %v", dstPort)
	}
}
